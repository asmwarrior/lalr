//
// debug.hpp
// Copyright (c) 2008 Charles Baker.  All rights reserved.
//

#ifndef SWEET_DEBUG_HPP_INCLUDED
#define SWEET_DEBUG_HPP_INCLUDED

#include <sweet/build.hpp>
#include <sweet/assert/assert.hpp>
#include "Trace.hpp"
#include "declspec.hpp"

namespace sweet
{

/**
 Debug library.

 The %debug library provides functions to handle system level exceptions, 
 get stack traces at runtime, and some simple functions for writing trace 
 information to a file.  

 If the macro SWEET_DEBUG_DUMP_ENABLED is defined then system exceptions
 cause a dump file to be written out.  The dump file is written to the
 applications current working directory with a name generated by the
 sweet::debug::filename_with_date_time_and_thread() function with a prefix
 of 'sweet-software' and a suffix of '.dmp'.  Otherwise system exceptions 
 left unhandled.

 For example starting up and shutting down the debug component:
@code
int main( int argc, char** argv )
{
    int result = EXIT_FAILURE;
    sweet::debug::startup();

    try
    {
        Application application( argc, argv );
        result = application.get_result();
    }

    catch ( const std::exception& exception )
    {
        fprintf( stderr, "build: An unexpected error occured - %s.\n", exception.what() );
        result = EXIT_FAILURE;
    }

    sweet::debug::shutdown();
    return result;
}
@endcode

 The stack trace and trace file functionality are useful for recording 
 useful information for later analysis offline.

 A good example of use is the memory library.  It overrides the memory 
 management functions used by the standard library (malloc(), calloc(), 
 realloc(), memalign(), free(), new, delete, new[], and delete[]) and 
 writes out each allocation and deallocation as it is made including the 
 call stack.

 This data is then able to be analysed later to detect memory leaks, double
 frees, and mismatched allocations and frees (e.g. allocating a block of 
 %memory with the new operator and deallocating with free()).
*/
namespace debug
{

SWEET_DEBUG_DECLSPEC void startup();
SWEET_DEBUG_DECLSPEC void shutdown();
SWEET_DEBUG_DECLSPEC bool is_debugger();
SWEET_DEBUG_DECLSPEC void stack_trace( void** addresses, size_t levels );
SWEET_DEBUG_DECLSPEC const char* filename_with_date_time_and_thread( const char* prefix, const char* suffix, char* buffer, size_t length );

}

}

#endif
